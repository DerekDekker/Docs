# 数据类型

```Rust

数值型    

字符串型 

浮点

布尔

容器型  

```

---
## 所有权

堆

可变, 可增长

需要在堆上分配一块在编译时未知大小的内存来存放内容

必须在运行时向内存分配器请求内存。

离开作用域后就被自动释放

建议使用场景: 结构体


```Rust
let s1 = String::from("hello");
let s2 = s1;

// 这时s1将无效
// s1与s2只是在栈上的 指针 长度 容量 数据是两份 但指向的是相同堆, Rust为了防止s1被回收而影响s2或造成重复回收而污染内存 所以s2被定义后s1将无效
```

---
## 字面量

栈

编译时就知道其内容, 快速且高效, 不可变性

包含: &str 整型 浮点型 Bool char 数组元组 等

建议场景: 函数参数

```Rust
// 会真正拷贝数据
let a:i32 =1;
let b:i32 = a;
```


---
## String



```rust
let 变量名 = String::from("值");

let 变量名 = "值".to_string();

// 创建空的
let mut 变量名 = String::new();

```

```Rust
// 替换 并返回一个新的
let name = String类型.replace("C++", "CPP")
```

```rust
let mut s = String::from("Hello");
s.push_str(", world!");  // 追加字符串
s.push('!');             // 追加字符
```

引用

在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。

引用必须总是有效的。

```Rust
let s1 = String::from("hello");

函数(&s1);
    
fn 函数(参数名: &String) -> usize {
    // 代码块
}
```

可变引用

同一时间只能有一个可变引用 需要释放后才能继续创建可变引用

不能在拥有不可变引用的同时拥有可变引用

```Rust
let s1 = String::from("hello");

函数(&mut s);
    
fn 函数(参数名: &mut String) -> usize {
    // 代码块
}
```

不再使用引用时可以使用可变引用

```Rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
println!("{} and {}", r1, r2);
// 此位置之后 r1 和 r2 不再使用

let r3 = &mut s; // 没问题
println!("{}", r3);
```

切片

```Rust
let s = String::from("hello world");

let s1 = &s[0..5];
let s2 = &s[6..11];
let s3 = &s[0..5];
let s4 = &s[6..];
let s4 = &s[..];
```

`.len()` 大小

`.clone()` 克隆




---
## &str

字符串切片

函数参数推荐使用, 可以接受 &str 与 String


```Rust
let greeting: &str = "Hello, world!";
```

---

## 整型

| 类型    | 字节            | 范围                                         |
|-------|---------------|--------------------------------------------|
| i8    | 1             | -128 到 127                                 |
| i16   | 2             | -32768 到 32767                             |
| i32   | 4             | -2147483648 到 2147483647                   |
| i64   | 8             | -9223372036854775808 到 9223372036854775807 |
| i128  | 16            | (2的129次方)/2                                |
| isize | 取决于平台 32 或 64 |                                            |
| u8    | 1             | 0 到 255                                    |
| u16   | 2             | 0 到 65535                                  |
| u32   | 4             | 0 到 4294967295                             |
| u64   | 8             | 0 到 18446744073709551615                   |
| u128  | 16            | 2的129次方                                    |
| usize | 取决于平台 32 或 64 |                                            |

---

## 浮点型

默认是f64, f64与f32在现代CPU中性能差距不大(不包括单片机之类)

| 类型  | 字节 | 范围      |
|-----|----|---------|
| f32 | 4  | 大约6位小数  |
| f64 | 8  | 大约15位小数 |

---

## Bool

| 类型   | 字节 |
|------|----|
| bool | 1  |

---

## char

需要用单引号进行定义

```rust
let char_literal = 'a'; 
```

| 类型   | 字节 | 范围 |
|------|----|----|
| char | 4  |    |

---

## 数组

元素必须相同 固定长度

```Rust
// 定义
let 名称 = [值, 值, 值];
let mut 名称 = [值, 值, 值];
```

`数组[0]`  获取元素

`数组[0] = 值`  赋值 元素

`数组.len()`  获取长度

## 元组

元素可以不同 固定长度

```Rust
// 定义
let 名称 = (值, 值, 值);
let mut 名称 = (值, 值, 值);
let 名称: (i32, f64, u8) = (500, 6.4, 1);
```

`元组.0`  获取元素

`元组.0 = 值`  赋值 元素

```Rust
// 大小
元组.len()
```

---
## 枚举


枚举可以定义方法和关联函数`impl`

```Rust
enum IpAddrKind {
    V4,
    V6,
}
let four = IpAddrKind::V4;


enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
    types(其它枚举),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));

```
